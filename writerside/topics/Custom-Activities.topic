<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Custom Activities" id="Custom-Activities" help-id="Custom-Activities" switcher-label="Mode">

    <show-structure depth="2"/>

    <p>
        Elsa is equipped with a comprehensive suite of prebuilt activities, designed to support a wide range of use cases, from basic operations like "Set Variable" to more advanced functions such as "Send Email." These out-of-the-box activities lay a solid foundation for efficiently constructing and managing workflows across a multitude of scenarios.
    </p>
    <p>
        Yet, to fully unlock Elsa's potential, it's highly recommended to craft domain-specific activities that cater to your unique requirements. By developing custom activities with your specific domain in mind, you can significantly enhance the workflow creation and management process, making it more streamlined and tailored to your operational needs.
    </p>
    <p>
        This guide will explore the creation of custom activities, providing insights and actionable steps on how to augment Elsa's functionality with custom solutions that seamlessly integrate with your domain.
    </p>

    <chapter title="Creating Custom Activities" id="creating-custom-activities">
        <p>
            To craft a custom activity, start by defining a new class that implements the <code>IActivity</code> interface or inherits from a base class that does. Examples include <code>Activity</code> or <code>CodeActivity</code>.
        </p>
        <p>A simple example of a custom activity is one that outputs a message to the console:</p>

        <code-block lang="c#" src="extensibility/custom-activities/PrintMessageActivity.cs"/>

        <chapter title="Anatomy of an Activity" id="anatomy-of-an-activity">

            <p>When developing custom activities for Elsa, understanding the basic structure and lifecycle of an activity is crucial.</p>
            <p>Let's dissect the sample PrintMessage activity.</p>

            <chapter title="Essential Components" id="activity-essential-components">
                <list>
                    <li>
                        <b>Inheritance</b>: The <code>PrintMessage</code> class inherits from <code>Elsa.Workflows.Activity</code>,
                        which implements the <code>IActivity</code> interface.
                    </li>
                    <li>
                        <b>Execution Method</b>: The core of an activity is the <code>ExecuteAsync</code> method. It defines the action
                        the activity performs when executed within a workflow.
                    </li>
                    <li>
                        <b>Activity Execution Context</b>: The <code>ActivityExecutionContext</code> parameter, named <code>context</code> here,
                        provides access to the workflow's execution context. It's a gateway to the workflow's environment,
                        offering methods to interact with the workflow's execution flow, data, and more.
                    </li>
                </list>
            </chapter>

            <chapter title="Key Operations" id="activity-key-operations">
                <list>
                    <li>
                        <b>Performing the Activity's Task</b>: Inside <code>ExecuteAsync</code>, the activity performs its intended
                        function. In this example, <code>Console.WriteLine("Hello world!");</code> demonstrates a simple operation
                        of printing a message to the console. In real-world scenarios, this is where the activity's
                        primary logic would reside, whether it's processing data or integrating with external systems.
                    </li>
                    <li>
                        <b>Completing the Activity</b>: The call to <code>await context.CompleteActivityAsync();</code> signifies
                        the completion of the activity's execution. Completing an activity is a critical step in
                        progressing the workflow to its next stage or activity.
                    </li>
                </list>
            </chapter>
        </chapter>

        <chapter title="Activity vs CodeActivity" id="activity-vs-code-activity">
            <p>When your custom activity's workflow is straightforward and concludes immediately after its task, inheriting from <code>CodeActivity</code> offers a streamlined approach. This base class is engineered to automatically signal the completion of the activity post-execution, eliminating the need for explicit completion logic.</p>
            <p>To illustrate, let's revisit the <code>PrintMessage</code> activity, this time reimagined using <code>CodeActivity</code> as its base. This example underscores the absence of manual completion:</p>
            <code-block lang="c#" src="extensibility/custom-activities/PrintMessageActivity.cs"/>
            <p>This approach allows developers to focus on the core logic of their activities without worrying about activity completion.</p>
        </chapter>

        <chapter title="Activity Metadata" id="activity-metadata">
            <p>When utilizing activities within tools such as <a href="Elsa-Studio.topic"/>, it presents an opportunity to convey user-friendly details about the activity, like its display name and description.</p>
            <p>Such information can be associated with your custom activity through the <code>ActivityAttribute</code>.</p>
            <p>Below is an example where the <code>ActivityAttribute</code> is applied to the <code>PrintMessage</code> activity:</p>
            <code-block lang="c#" src="extensibility/custom-activities/PrintMessageWithActivityMetadata.cs"/>
            <p>In this case, the activity is annotated with a namespace of <code>"MyCompany"</code> and a description for clarity.</p>
        </chapter>
    </chapter>

    <chapter title="Registering Activities" id="registering-activities">
        <p>For activities to be usable within workflows, they must first be registered within the system.</p>
        <p>This involves registering them with a service known as the <emphasis>Activity Registry</emphasis>.</p>
        <p>The most straightforward method is through your application's initialization code. For instance, the <path>Program.cs</path> file below illustrates how to register the <code>PrintMessage</code> activity:</p>
        <code-block lang="c#" src="extensibility/custom-activities/Program1.cs"/>
        <p>Alternatively, to register all activities from a specific assembly, the <code>AddActivitiesFrom&lt;TMarker&gt;</code> extension method can be utilized:</p>
        <code-block lang="c#" src="extensibility/custom-activities/Program2.cs"/>
        <p>This approach registers all activities discovered within the assembly containing the specified type. The marker type can be any class within the assembly, not necessarily an activity. It serves as a pointer to the assembly to be searched for activity types.</p>
    </chapter>

    <chapter title="Input" id="activity-input">
        <p>Similar to C# methods and JavaScript functions, activities can accept <emphasis>input</emphasis> and generate <emphasis>output</emphasis>.</p>
        <p>In essence, an activity functions within a workflow much like a statement within a program, serving as a fundamental component that constructs the logic of the workflow.</p>
        <p>To define inputs, simply expose public properties within your activity class. For instance, the <code>PrintMessage</code> activity below is updated to receive a message as input:</p>
        <code-block lang="c#" src="extensibility/custom-activities/PrintMessageWithInput.cs"/>
        <chapter title="Input Metadata" id="input-metadata">
            <p>Utilizing activities within tools such as <a href="Elsa-Studio.topic"/>, offers a chance to provide accessible information about the activity's inputs, including display names and descriptions.</p>
            <p>This detail can be appended to your custom activity's input property using the <code>InputAttribute</code>.</p>
            <p>Here is an instance where the <code>InputAttribute</code> is applied to the <code>Message</code> property:</p>
            <code-block lang="c#" src="extensibility/custom-activities/PrintMessageWithInputMetadata.cs"/>
            <p>In this example, the <code>Message</code> input property is embellished with a description for better understanding.</p>
        </chapter>
        <chapter title="Expressions" id="activity-input-expressions">
            <p>Often, you'll want to dynamically set the activity's input through expressions, instead of fixed, literal values.</p>
            <p>For instance, you might want the message to be printed to originate from a workflow variable, rather than being hardcoded into the activity's input.</p>
            <p>To enable this, you should encapsulate the input property type within <code>Input&lt;T&gt;</code>.</p>
            <p>As an illustration, the <code>PrintMessage</code> activity below is modified to support expressions for its <code>Message</code> input property:</p>
            <code-block lang="c#" src="extensibility/custom-activities/PrintMessageWithExpressionInput.cs"/>
            <p>Note that encapsulating an input property with <code>Input&lt;T&gt;</code> changes the manner in which its value is accessed:</p>
            <code-block lang="c#" src="extensibility/custom-activities/PrintMessageWithExpressionInput.cs" include-lines="11"/>
            <if switcher-key="Programmatic">
                <p>The example below demonstrates specifying an expression for the <code>Message</code> property in a workflow created using the workflow builder API:</p>
                <code-block lang="c#" src="extensibility/custom-activities/PrintMessageWorkflow1.cs"/>
                <p>In this scenario, we utilize a simple C# delegate expression to dynamically determine the message to print at runtime.</p>
                <p>Alternatively, other installed expression provider syntaxes, such as JavaScript, can be employed:</p>
                <code-block lang="c#" src="extensibility/custom-activities/PrintMessageWorkflow2.cs"/>
                <p>The only variance is in the creation of the expression:</p>
                <code-block lang="c#" src="extensibility/custom-activities/PrintMessageWorkflow2.cs" include-lines="15-15"/>
            </if>
            <if switcher-key="Designer">
                <p>When an input property is encapsulated with <code>Input&lt;T&gt;</code>, Elsa Studio enables the user to select from any installed syntaxes for input:</p>
                <img src="activity-input-metadata-1.png" alt="Activity input and different syntax support" border-effect="rounded" thumbnail="true"/>
            </if>
        </chapter>
    </chapter>

    <chapter title="Output" id="activity-output">
        <p>Activities are capable of generating outputs, achieved by implementing properties typed as <code>Output&lt;T&gt;</code>.</p>
        <p>For instance, the activity below generates a random number between 0 and 100:</p>
        <code-block lang="c#" src="extensibility/custom-activities/GenerateRandomNumber1.cs"/>
        <chapter title="Output Metadata" id="output-metadata">
            <p>Similarly to input properties, output properties can be enriched with metadata.</p>
            <p>This is accomplished using the <code>OutputAttribute</code>.</p>
            <p>An example of the <code>OutputAttribute</code> applied to the <code>Result</code> property follows:</p>
            <code-block lang="c#" src="extensibility/custom-activities/GenerateRandomNumber2.cs"/>
            <p>In this instance, the <code>Result</code> output property is adorned with a description for enhanced clarity.</p>
        </chapter>
        <p>There are two approaches to managing activity output:</p>
        <list type="decimal">
            <li>Capturing the output via a workflow variable</li>
            <li>Direct access to the output from the workflow engine's memory register</li>
        </list>
        <p>Let's examine both methods in detail.</p>
        <chapter title="Capture via Variable" id="capture-output-via-variable">
            <if switcher-key="Programmatic">
                <p>Firstly, here's how to capture the output using a workflow variable:</p>
                <code-block lang="c#" src="extensibility/custom-activities/GenerateRandomNumberWorkflow1.cs"/>
                <p>In this workflow, the steps include:</p>
                <list>
                    <li>Executing the <code>GenerateRandomNumber</code> activity</li>
                    <li>Capturing the activity's output in a variable named <code>RandomNumber</code></li>
                    <li>Displaying a message with the value of the <code>RandomNumber</code> variable</li>
                </list>
            </if>
            <if switcher-key="Designer">
                <p>To capture output via a variable, follow these steps:</p>
                <procedure>
                    <step>
                        <p>Create a new workflow</p>
                        <img src="random-number-workflow-1.png" alt="Create a new workflow called Random Number Workflow" border-effect="rounded"/>
                    </step>
                    <step>
                        <p>Establish a new variable of type <code>decimal</code> named <emphasis>RandomNumber</emphasis></p>
                        <img src="random-number-workflow-2.png" alt="Create a new workflow called Random Number Workflow" border-effect="rounded" thumbnail="true"/>
                    </step>
                    <step>
                        <p>Integrate the <ui-path>Generate Random Number</ui-path> activity into the canvas and link its Result output to the <ui-path>RandomNumber</ui-path> variable.</p>
                        <img src="random-number-workflow-3.png" alt="Add activity and bind output" border-effect="rounded" thumbnail="true"/>
                    </step>
                    <step>
                        <p>Add the <ui-path>Print Message</ui-path> activity to the canvas and set up its <ui-path>Message</ui-path> property with a JavaScript expression leveraging the variable.</p>
                        <p>Ensure the activities are connected.</p>
                        <img src="random-number-workflow-4.png" alt="Add activity and bind output" border-effect="rounded" thumbnail="true"/>
                    </step>
                </procedure>
            </if>
        </chapter>
        <chapter title="Direct Access" id="direct-access">
            <if switcher-key="Programmatic">
                <p>Now, let's explore direct access to the output from the <code>GenerateRandomNumber</code> activity:</p>
                <code-block lang="c#" src="extensibility/custom-activities/GenerateRandomNumberWorkflow2.cs"/>
                <p>This requires naming the activity from which the output will be accessed, as well as the output property's name.</p>
                <p>An alternative, type-safe method is to declare the activity as a local variable initially. This allows for referencing both the activity and its output, as demonstrated below:</p>
                <code-block lang="c#" src="extensibility/custom-activities/GenerateRandomNumberWorkflow3.cs"/>
            </if>
            <if switcher-key="Designer">
                <p>To directly access the output from the <ui-path>Generate Random Number</ui-path> activity, follow these steps:</p>
                <procedure>
                    <step>
                        <p>Remove the RandomNumber variable</p>
                        <img src="random-number-workflow-5.png" alt="Delete the RandomNumber variable" border-effect="rounded" thumbnail="true"/>
                    </step>
                    <step>
                        <p>Upon adding an activity to the canvas, the designer automatically assigns it a default name. Use the name <code>GenerateRandomNumber1</code> for the <ui-path>Generate Random Number</ui-path> activity as an example.</p>
                        <img src="random-number-workflow-6.png" alt="The name of the activity" border-effect="rounded" thumbnail="true"/>
                        <p>Knowing the activity's name, update the <ui-path>Print Message</ui-path> activity's <ui-path>Message</ui-path> property with the following expression to access its output:</p>
                        <tabs>
                            <tab title="JavaScript">
                                <code-block lang="javascript">
                                    const randomNumber = getResultFromGenerateRandomNumber1();
                                    return `The random number is: ${randomNumber}`;
                                </code-block>
                            </tab>
                            <tab title="C#">
                                <code-block lang="c#">
                                    var randomNumber = Output.From&lt;decimal&gt;("GenerateRandomNumber1", "Result");
                                    return $"The random number is: {randomNumber}";
                                </code-block>
                            </tab>
                        </tabs>

                    </step>
                </procedure>

            </if>
        </chapter>
        <p>While both approaches are effective for managing activity output, it's crucial to note a key distinction: activity output is <emphasis>transient</emphasis>, existing only for the duration of the <a href="Overview.topic" anchor="burst-of-execution" summary="As the workflow runner executes activities, it performs what is known as a burst of execution. Click to learn more.">current execution burst</a>.</p>
        <p>To access the output value beyond these bursts, capturing the output in a variable is recommended, as <emphasis>variables are inherently persistent</emphasis>.</p>
    </chapter>

    <chapter title="Activity Providers" id="activity-providers">
        <p>Activities can be supplied to the system in various ways, fundamentally represented by an <emphasis>Activity Descriptor</emphasis>.</p>
        <p>Such descriptors are furnished by a construct known as <emphasis>Activity Providers</emphasis>, with one implementation being the <code>TypedActivityProvider</code>. This provider generates activity descriptors based on the .NET types implementing the <code>IActivity</code> interface.</p>
        <p>This abstraction layer enables sophisticated scenarios where activity descriptors' sources can be dynamic.</p>
        <p>For instance, Elsa facilitates the definition of workflows that can then be executed as activities. Via a specialized activity provider, these workflows manifest as toolbox-available activities.</p>
        <p>An additional use case involves generating activities from an Open API specification, automatically representing each resource operation as an activity instead of directly utilizing the <code>SendHttpRequest</code> activity.</p>
        <p>To develop custom activity providers, adhere to the following steps:</p>
        <list type="decimal">
            <li>Implement the <code>Elsa.Workflows.Contracts.IActivityProvider</code></li>
            <li>Register your custom activity provider with the system</li>
        </list>
        <p>Below is a sample implementation of an activity provider:</p>
        <code-block lang="c#" src="extensibility/custom-activities/FruitActivityProvider.cs"/>
        <p>This provider leverages a simple array of fruit names as its source, generating an activity descriptor for each fruit, symbolizing a "Buy (fruit)" activity.</p>
        <p>To register this provider, utilize the <code>AddActivityProvider&lt;T&gt;</code> extension method:</p>
        <code-block lang="c#" src="extensibility/custom-activities/Program3.cs"/>
        <note title="Programmatic Workflows and Dynamic Activities">
            <p>Currently, dynamically provided activities cannot be utilized within programmatic workflows.</p>
            <p>An open issue exists for this functionality: <a href="https://github.com/elsa-workflows/elsa-core/issues/5162">https://github.com/elsa-workflows/elsa-core/issues/5162</a></p>
        </note>
    </chapter>

    <chapter title="Summary" id="summary">
        <p>This exploration has equipped us with the knowledge to enhance Elsa through the integration of custom activities.</p>
        <p>Creating a custom activity entails developing a new class that either directly or indirectly implements the <code>IActivity</code> interface.</p>
    </chapter>
</topic>
